# 3.3 VIRTUAL MEMORY

Mientras que los registro base y limite pueden ser usados para crear la abstracción de direcciones de memoria, hay otro problema que debe ser resuelto: gestión del bloatware. Mientras que los tamaños de memoria incrementan rápidamente, los tamaños del software incrementan mucho más rápido. En 1980, muchas universidades ejecutaban un sistema timesharing con docenas de usuarios(masomenso satisfechos) que funcionaban simultáneamente en una VAX de 4 MB. Ahora Microsoft recomienda tener al menos 2GB para Windows 8 de 64 bits. La tendencia hacia el multimedia exige aún más memoria. 

En consecuencia a este desarrollo, existe una necesidad de ejecutar programas que son muy grandes para caber en memoria, además un sistema debe soportar multiples programas ejecutándose simultáneamente, cada uno de los cuales cabe en memoria, pero juntos exceden colectivamente la memoria. El intercambio no es una opción atractiva, ya que un disco SATA típico tiene una velocidad de transferencia máxima de varios cientos de MB/s, lo que significa que se tarda segundos en intercambiar un programa de 1GB y lo mismo en intercambiar otro programa de 1GB.

El problema con los problemas más grandes que la memoria existen desde los inicios de las computadoras, aunque en ámbitos limitados como la ciencia y la ingeniería(simular la creación del universo o incluso simular un nuevo avión requiere mucha memoria). Una solución adoptada en los años 60 fue dividir los programas en pequeños trozos, llamados **overlay**. Cuando se iniciaba un programa, lo único que se cargaba en memoria era el gestor de overlay, que inmediatamente cargaba y ejecutaba la superposición 0. Cuando terminaba, le decia al overlay manager que cargara el overlay 1, ya sea encima de la posición 0 en memoria (si habia espacio para ella) o encima del overlay 0(si no habia espacio). Algunos sistemas de overlay eran muy complejos y permitian varios overlay en memoria al mismo tiempo.

Los overlays se guardaban en el disco y el gestor de overlay las intercambiaba dentro y fuera de la memoria.

Aunque el sistema operativo se encargaba de introducir y extraer los overlays, el programador tenia que dividir el programa en partes manualmente. Dividir programas grandes en partes pequeñas y modulares llevaba mucho tiempo, era aburrido y propenso a errores. Pocos programadores eran buenos en esto. No pasó mucho tiempo antes de que a alguien se le ocurriera la manera de delegar todo el trabajo a la computadora.

El método ideado(Fotherigam, 1961) se conoce como **virtual memory**. La idea básica bajo la memoria virtual es que cada programa tenga su propio espacios de direcciones, el cual se divide en trozos llamados páginas. Cada página es un rango continuo de direcciones. Estas páginas se mapean en la memoria física, pero no todas las páginas tienen que estar en la memoria física al mismo tiempo para ejecutar el programa. Cuando un programa hace referencia a una parte de su espacio de memoria que está en la dirección física, el hardware realiza el mapeo necesario. Cuando el programa hace referencia a una parte de su espacio de memoria que no está en la memoria física, se avisa al sistema operativo para que busque la parte que falta y vuelva a ejecutar la instrucción que falló.

En cierto sentido, la memoria virtual es una generalización de la idea de los registros base y límite. El 8088 tenía registros base separados(pero no registros límite)para texto y datos. Con la memoria virtual en lugar de tener una reubicación separada sólo para los segmentos de texto y datos, todo el espacio de direcciones puede ser mapeado en la memoria física en unidades bastante pequeñas. Más adelante veremos cómo se implementa la memoria virtual. La memoria virtual funciona perfectamente en un sistema multiprogramación, con fragmentos de muchos programas en memoria a la vez. Mientras un programa está esperando a que se lean partes de sí mismo, la CPU puede ser entregada a otro proceso.

## 3.3.1 Paging

La mayoría de los sistemas de memoria virtual utilizan una técnica llamada paginación, que describiremos a continuación. En cualquier ordenador, los programas hacen referencia a un conjunto de direcciones de memoria. Cuando un programa ejecuta una instrucción como:

``` assembler
    MOV REG, 1000
```

lo hace para copiar el contenido de la dirección de memoria 1000 a REG (o viceversa, según el ordenador). Las direcciones pueden generarse utilizando indexación, registros base, registros de segmento y otras formas.



Estas direcciones generadas por el prograsma se llaman **virtual addreses** y forman el  **virtual address space**. En computadoras sin memoria virtual, la dirección virtual es puesta directamente el bus de direcciones y hace que se lea y escriba la palabra de memoria física con la misma dirección.

Cuando se usa memoria virtual, las direcciones virtuales no van directamente al bus de memoria. En vez de ello, ellos van al **MMU(Memory Management Unit)** que mapea las direcciones virtuales en direciones físicas como se ve en la figura 3-8.

[figure3-8]

Un ejemplo bastante simple de como se mapea se ve en la figura 3-9. En este ejemplo, tenemos una computadora que genera 16 bits de direcciones desde 0 hasta 64K-1. Estas son direcciones virtuales. Esta computadora, de todos modos tiene solo 32KB de memoria física. Por lo tanto, aunque se pueden escribir programas de 64 KB, no se pueden cargar en memoria en su totalidad y ejecutarse. Sin embargo, en el disco debe haber una copia completa de la imagen central del programa, de hasta 64KB, para que puedan introducirse piezas cuando sea necesario.

El espacio de direcciones virtuales se compone de unidades de tamaño fijo denominadas páginas. Las unidades correspondientes en la memoria física se llaman **page frames**. Las páginas y los marcos de página suelen tener el mismo tamaño. En este ejemplo son 4KB, pero en sistemas reales se han utilizado tamaños de página desde 512 bytes hasta 1 GB. Con 64KB de espacio de direcciones virtuales y 32KB de memoria física, obtenemos 16 páginas virtuales y 8 marcos de página. Las transferencias entre RAM y disco se realizan siempre en páginas enteras. Muchos procesadores soportan múltiples tamaños de página que pueden mezclarse y combinarse como el sistema operativo considere oportuno. Por ejemplo, la arquitectura x86-64 admite páginas de 4KB, 2MB y 1GB, por lo que podríamos usar páginas de 4KB para las aplicaciones de usuario y una única página de 1GB para el núcleo. Más adelante veremos por qué aveces es mejor usar única página grande, en lugar de un gran número de páginas pequeñas.

La notación de la figura 3-9 es así. El rango marcado de 0K a 4K significa que la memoria ya sea virtual o física en esa página van de 0 a 4095. El rango 4K-8K hace referencia a que las direcciones de 4096 a 8191 y así. Cada página contiene exactamente 4096 direcciones comenzando desde un múltiplo de 4096 y terminando con un múltiplo de 4096 menos 1. Cuando el programa rata de acceder a la dirección 0, por ejemplo, usa la instrucción.

``` assembler
    MOV REG, 1000
```