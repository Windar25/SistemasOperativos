#  4.3 FILE SYSTEM IMPLEMENTATION

Ahora es el momento de pasar de la visión del usuario del sistema de archivos a la visión del implementador. A los usuarios les preocupa cómo se nombran los archivos, qué operaciones se permiten sobre ellos, qué aspecto tiene el árbol de directorios y otras cuestiones similares relacionadas con la interfaz. A los implementadores les interesa cómo se almacenan los archivos y directorios, cómo se gestiona el espacio en disco y cómo hacer que todo funcione de forma eficiente y fiable. En las secciones siguientes examinaremos algunas de estas áreas para ver cuáles son los problemas y las desventajas.

# 4.3.1 File-System Layout

Los sistemas de archivos se almacenan en discos. La mayoría de los discos pueden dividirse en una o más particiones, con sistemas de archivos independientes en cada partición. El sector 0 del disco se denomina **MBR (Master Boot Record)** y se utiliza para arrancar el ordenador. Esta tabla indica las direcciones inicial y final de cada partición. Una de las particiones de la tabla está marcada como activa. Cuando se arranca el ordenador, la BIOS lee y ejecuta el MBR. Lo primero que hace el programa MBR es localizar la partición activa, leer su primer bloque, que se llama  **boot block**, y ejecutarlo. El programa en el bloque de arranque carga el sistema operativo contenido en esa partición. Por uniformidad, la partición comienza con un **boot block**, aunque no contenga un sistema operativo de arranque. Además, podría contener uno en el futuro. Aparte de comenzar con un bloque de arranque, la disposición de una partición de disco varía mucho de un sistema de archivos a otro. A menudo, el sistema de archivos contendrá algunos de los elementos que se muestran en la Fig. 4-9. El primero es el **superblock**. Contiene todos los parámetros clave sobre el sistema de ficheros y se lee en memoria cuando se arranca el ordenador o se toca el sistema de ficheros por primera vez. La información típica en el superblock incluye un número mágico para identificar el tipo de sistema de archivos, el número de bloques en el sistema de archivos y otra información administrativa clave.

[figure4.9]

A continuación puede venir la información sobre los bloques libres en el sistema de archivos, por ejemplo, en forma de mapbit o lista de punteros. A continuación, pueden aparecer los i nodos, un array de data structure, una por cada archivo, que lo describen todo del archivo. Después puede venir el root directory, que contiene la parte superior del árbol del file system. Por último, el resto del disco contiene todos los demás directorios y archivos.

## 4.3.2 Implementing Files

Probablemente, el problema más importante a la hora de almacenar archivos es saber qué bloques de disco corresponden a cada file. En los distintos sistemas operativos se utilizan varios métodos. En esta sección examinaremos algunos de ellos.

### Contiguos Allocation

El esquema de asignación más sencillo consiste en almacenar cada archivo como una serie contigua de bloques de disco. Así, en un disco con bloques de 1 KB, a un file de 50 KB se le asignarían 50 bloques consecutivos. Con bloques de 2 KB, se le asignarían 25 bloques consecutivos. Vemos un ejemplo de asignación de almacenamiento contiguo en la Fig. 4-10(a).  Aquí se muestran los primeros 40 bloques de disco, comenzando con el bloque 0 a la izquierda. Inicialmente, el disco estaba vacío. Luego un archivo A, de cuatro bloques de longitud, fue escrito en el disco comenzando por el principio (bloque 0). Después se escribió un archivo de seis bloques, B, empezando justo después del final del archivo A.

Tenga en cuenta que cada archivo comienza al principio de un nuevo bloque, de modo que si el archivo A tenía realmente 3½ bloques, se desperdicia algo de espacio al final del último bloque. En la figura se muestra un total de siete files, cada uno de los cuales comienza en el bloque siguiente al final del anterior. El sombreado se utiliza sólo para que sea más fácil distinguir los archivos. No tiene ninguna importancia real en términos de almacenamiento.

[figure4-10]

La asignación continua de espacio en disco tiene dos ventajas significativas. En primer lugar, es fácil de implementar, ya que para saber dónde están los bloques de un archivo sólo hay que recordar dos números: la dirección de disco del primer bloque y el número de bloques del archivo. Dado el número del primer bloque, el número de cualquier otro bloque se puede encontrar mediante una simple suma.

En segundo lugar, el rendimiento de lectura es excelente, ya que todo el archivo puede leerse desde el disco en una sola operación.  Sólo es necesaria una búsqueda (hasta el primer bloque). A partir de ese momento, ya no se necesitan más búsquedas ni retardos de rotación, por lo que los datos llegan con todo el ancho de banda del disco. Por lo tanto, la asignación continua es fácil de implementar y tiene un alto rendimiento.

Desafortunadamente, la asignación contigua también tiene un grave inconveniente: con el paso del tiempo, el disco se fragmenta. Para ver cómo ocurre esto, examine la Fig. 4-10(b).  Aquí dos ficheros, D y F, han sido eliminados. Cuando se vuelve a mover un fichero, sus bloques se liberan de forma natural, dejando una serie de bloques libres en el disco. 

Desafortunadamente, la asignación contigua también tiene un grave inconveniente: con el paso del tiempo, el disco se fragmenta. Para ver cómo ocurre esto, examine la Fig. 4-10(b).  Aquí dos ficheros, D y F, han sido eliminados. Cuando se vuelve a mover un fichero, sus bloques se liberan de forma natural, dejando una serie de bloques libres en el disco. El disco no se compacta en el momento para eliminar el agujero, ya que eso implicaría copiar todos los bloques que siguen al agujero, potencialmente millones de bloques, lo que llevaría horas o incluso días con discos grandes. Como resultado, el disco se compone en última instancia de files y holes, como se ilustra en la figura.

Inicialmente, esta fragmentación no es un problema, ya que cada nuevo file puede escribirse al final del disco, a continuación del anterior. Sin embargo, con el tiempo el disco se llenará y será necesario compactarlo, lo que es prohibitivamente caro, o reutilizar el espacio libre en los huecos. Reutilizar el espacio requiere mantener una lista de huecos, lo que es factible. Sin embargo, cuando se va a crear un nuevo archivo, es necesario conocer su tamaño final para elegir un agujero del tamaño correcto en el que colocarlo.

Imagine las consecuencias de un diseño así. El usuario inicia un procesador de textos para crear un documento. Lo primero que pregunta el programa es cuántos bytes tendrá el documento final. La pregunta debe responderse o el programa no continuará.  Si al final el número dado resulta ser demasiado pequeño, el programa tiene que terminar prematuramente porque el hueco del disco está lleno y no hay sitio para meter el resto del archivo.  Si el usuario trata de evitar este problema dando un número irrealmente grande como tamaño final, por ejemplo, 1 GB, el editor puede ser incapaz de encontrar un agujero tan grande y anunciar que el archivo no se puede crear. Por supuesto, el usuario sería libre de iniciar el programa de nuevo y decir 500 MB esta vez, y así sucesivamente hasta que se encontró un agujero adecuado. Aun así, no es probable que este esquema haga felices a los usuarios.

Sin embargo, hay una situación en la que la asignación contigua es factible y, de hecho, todavía se utiliza: en los CD-ROM.  En este caso, todos los tamaños de archivo se conocen de antemano y nunca cambiarán durante el uso posterior del sistema de archivos del CD-ROM. 

La situación con los DVD es un poco más complicada. En principio, una película de 90 minutos podría codificarse como un único archivo de unos 4,5 GB de longitud, pero el file system utilizado, UDF (Universal Disk Format), utiliza un número de 30 bits para representar la longitud de los archivos, lo que los limita a 1 GB. En consecuencia, las películas en DVD suelen almacenarse en tres o cuatro archivos de 1 GB, cada uno de ellos contiguo. Estas partes físicas de un único archivo lógico (la película) se denominan **extents**.

Como mencionamos en el Capítulo 1, la historia se repite a menudo en informática a medida que aparecen nuevas generaciones de tecnología. La asignación contigua se utilizaba en los sistemas de archivos de disco magnético hace años debido a su simplicidad y alto rendimiento (la facilidad de uso no contaba mucho entonces). Luego se abandonó la idea debido a la molestia de tener que especificar el tamaño final del archivo en el momento de crearlo. Pero con la llegada de los CD-ROM, DVD, Blu-ray y otros soportes ópticos de una sola escritura, los archivos contiguos volvieron a ser una buena idea.  Por eso es importante estudiar los sistemas antiguos y las ideas que eran conceptualmente limpias y sencillas, porque pueden aplicarse a sistemas futuros de forma sorprendente.

### Linked-List Allocation

El segundo método para almacenar ficheros es mantener cada uno como una lista enlazada de bloques de disco, como se muestra en la Fig. 4-11.  La primera palabra de cada bloque se utiliza como puntero al siguiente. El resto del bloque es para datos.

[figure4-11]

A diferencia de la asignación contigua, en este método se pueden utilizar todos los bloques de disco. No se pierde espacio por la fragmentación del disco (salvo la fragmentación interna del último bloque).  Además, basta con que la entrada del directorio almacene la dirección de disco del primer bloque. El resto puede encontrarse a partir de ahí. Por otra parte, aunque la lectura secuencial de un fichero es sencilla, el acceso aleatorio es extremadamente lento.  Para llegar al bloque n, el sistema operativo tiene que empezar por el principio y leer los n - 1 bloques anteriores, de uno en uno. Está claro que hacer tantas lecturas será terriblemente lento.

Además, la cantidad de datos almacenados en un bloque ya no es una potencia de dos porque el puntero ocupa unos pocos bytes. Aunque no es fatal, tener un tamaño peculiar es menos eficiente porque muchos programas leen y escriben en bloques cuyo tamaño es una potencia de dos. Con los primeros bytes de cada bloque ocupados por un puntero al siguiente bloque, las lecturas del tamaño del bloque completo requieren adquirir y concatenar información de dos bloques de disco, lo que genera una sobrecarga adicional debido a la copia.

## Linked-List Allocation Using a Table in Memory

Ambas desventajas de la asignación de listas enlazadas pueden eliminarse tomando la palabra puntero de cada bloque de disco y poniéndola en una tabla en memoria. La Figura 4-12 muestra el aspecto de la tabla para el ejemplo de la Fig. 4-11. En ambas figuras, tenemos dos archivos. El archivo A usa los bloques de disco 4, 7, 2, 10 y 12, en ese orden, y el archivo B usa los bloques de disco 6, 3, 11 y 14, en ese orden. Usando la tabla de la Fig. 4-12, podemos empezar por el bloque 4 y seguir la cadena hasta el final. Lo mismo se puede hacer empezando por el bloque 6. Ambas cadenas terminan con un marcador especial (por ejemplo, -1) que no es un número de bloque válido. Una tabla de este tipo en la memoria principal se denomina FAT (File Allocation Table).

[figure4-12]

Con esta organización, todo el bloque está disponible para los datos. Además, el random access es mucho más fácil. Aunque todavía hay que seguir la cadena para encontrar un desplazamiento determinado dentro del archivo, la cadena está completamente en memoria, por lo que se puede seguir sin hacer ninguna referencia al disco. Al igual que en el método anterior, basta con que la entrada del directorio mantenga un único número entero (el número de bloque inicial) para poder localizar todos los bloques, independientemente de lo grande que sea el fichero. 

La principal desventaja de este método es que toda la tabla debe estar en memoria todo el tiempo para que funcione. Con un disco de 1 TB y un tamaño de bloque de 1 KB, la tabla necesita 1.000 millones de entradas, una por cada uno de los 1.000 millones de bloques de disco. Cada entrada debe tener un mínimo de 3 bytes. Para acelerar la búsqueda, deben ser de 4 bytes. Así, la tabla ocupará 3 GB o 2,4 GB de memoria principal todo el tiempo, dependiendo de si el sistema está optimizado para el espacio o el tiempo. No es muy práctico. Está claro que la idea de la FAT no se adapta bien a los discos grandes. Fue el file system original de MS-DOS y, sin embargo, sigue siendo totalmente compatible con todas las versiones de Windows.

### I-nodes

Nuestro último método para llevar la cuenta de qué bloques pertenecen a qué archivo es asociar a cada archivo una estructura de datos llamada nodo-i (nodo-índice), que enumera los atributos y las direcciones de disco de los bloques del archivo.  En la Fig. 4-13 se muestra un ejemplo sencillo.  A partir del i-node, es posible encontrar todos los bloques del archivo.

La gran ventaja de este esquema sobre los ficheros enlazados que utilizan una tabla en memoria es que el nodo-i sólo necesita estar en memoria cuando el fichero correspondiente está abierto. Si cada nodo-i ocupa n bytes y puede haber un máximo de k ficheros abiertos a la vez, la memoria total ocupada por la matriz que contiene los i-nodos de los ficheros abiertos es de sólo kn bytes. Sólo es necesario reservar este espacio por adelantado.

[figure4-13]


Preguntas:

Explica la imagen 4.9

Qué es el algoritmo continue locating?
Que pros tiene?
Que contras?

