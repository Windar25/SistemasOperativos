### The Linux Ext2 File System

A continuación describiremos uno de los sistemas de archivos en disco más populares utilizados en Linux: **ext2**. La primera versión de Linux utilizaba el sistema de archivos MINIX 1 y estaba limitado por nombres de archivo cortos y tamaños de archivo de 64 MB. Con el tiempo, el sistema de archivos MINIX 1 fue sustituido por el primer sistema de archivos extendido, ext, que permitía nombres de archivo más largos y archivos de mayor tamaño. Debido a sus deficiencias de rendimiento, ext fue sustituido por su sucesor, ext2, que todavía se utiliza ampliamente.

Una partición de disco Linux ext2 contiene un sistema de archivos con la disposición mostrada en la Fig. 10-31. El bloque 0 no es utilizado por Linux y contiene código para arrancar el ordenador. El bloque 0 no es utilizado por Linux y contiene código para arrancar el ordenador.Después del bloque 0, la partición de disco se divide en grupos de bloques, independientemente de dónde caigan los límites del cilindro de disco. Cada grupo está organizado de la siguiente manera.

El primer bloque es el **superblock**. Contiene información sobre la disposición del sistema de archivos, incluido el número de nodos-i, el número de bloques de disco y el inicio de la lista de bloques de disco libres (normalmente unos cientos de entradas). A continuación viene el descriptor de grupo, que contiene información sobre la ubicación de losbitmaps, el número de bloques libres y de i-nodos en el grupo, y el número de di-rectorios en el grupo. Esta información es importante ya que ext2 intenta distribuir los directorios uniformemente por el disco.

[figure10-31]

Se utilizan dos mapas de bits para llevar la cuenta de los bloques libres y los nodos-i libres, respectivamente, una opción heredada del sistema de archivos MINIX 1 (y en contraste con la mayoría de los sistemas de archivos UNIX, que utilizan una lista de libres). Cada mapa tiene un bloque de longitud. Con un bloque de 1 KB, este diseño limita un grupo de bloques a 8192 bloques y 8192 i-nodos. La primera es una restricción real pero, en la práctica, la segunda no lo es. Con bloques de 4 KB, los números son cuatro veces mayores.

Tras el superbloque se encuentran los propios nodos i. Están numerados de 1 a un máximo. Cada nodo-i tiene 128 bytes y describe exactamente un archivo.  Un nodo-i contiene información contable (incluida toda la información devuelta por stat, que simplemente la toma del nodo-i), así como información suficiente para localizar todos los bloques de disco que contienen los datos del archivo.

Tras los nodos i se encuentran los bloques de datos. Aquí se almacenan todos los archivos y directorios. Si un archivo o directorio consta de más de un bloque, los bloques no tienen por qué ser contiguos en el disco. De hecho, es probable que los bloques de un archivo grande estén repartidos por todo el disco.

Los nodos I correspondientes a los directorios están dispersos por los grupos de bloques del disco. Ext2 se esfuerza por colocar los archivos ordinarios en el mismo grupo de bloques que el directorio principal, y los archivos de datos en el mismo bloque que el nodo-i del archivo original, siempre que haya espacio suficiente. Esta idea se tomó prestada del sistema FastFile de Berkeley (McKusick et al., 1984). Los mapas de bits se utilizan para tomar decisiones rápidas sobre dónde asignar los nuevos datos del sistema de archivos. Cuando se asignan nuevos bloques de archivo, ext2 también preasigna un número (ocho) de bloques adicionales para ese archivo, con el fin de minimizar la fragmentación del archivo debido a futuras operaciones de escritura. Este esquema equilibra la carga del sistema de archivos en todo el disco. También ofrece un buen rendimiento gracias a su tendencia a la colocación y a la reducción de la fragmentación.

Para acceder a un archivo, primero debe utilizar una de las llamadas del sistema Linux, como *open*, que requiere el nombre de la ruta del archivo. El nombre de la ruta se analiza para extraer directorios individuales.  Si se especifica una ruta relativa, la búsqueda comienza en el directorio actual del proceso; de lo contrario, comienza en el directorio raíz. En cualquier caso, el nodo-i para el primer directorio puede localizarse fácilmente: hay un puntero a él en el de-scriptor del proceso, o, en el caso de un directorio raíz, normalmente se almacena en un bloque predeterminado del disco.

El archivo de directorio permite nombres de archivo de hasta 255 caracteres y se ilustra en laFig. 10-32. Cada directorio consta de un número entero de bloques de disco para que los directorios puedan escribirse atómicamente en el disco. Dentro de un directorio, las entradas para archivos y directorios están en orden no clasificado, con cada entrada directamente a continuación de la anterior. Las entradas no pueden abarcar bloques de disco, por lo que a menudo hay un número de bytes no utilizados al final de cada bloque de disco.

Cada entrada de directorio de la Fig. 10-32 consta de cuatro campos de longitud fija y un campo de longitud variable. El primer campo es el número de nodo i, 19 para el fichero colossal,42 para el fichero voluminous, y 88 para el directorio bigdir. A continuación viene un campo rec len, que indica el tamaño de la entrada (en bytes), posiblemente incluyendo algo de relleno después del nombre. Este campo es necesario para encontrar la siguiente entrada en el caso de que el nombre del fichero tenga una longitud desconocida. Este es el significado de la flecha de la Fig. 10-32. Luego viene el campo de tipo: archivo, directorio, etc. El último campo fijo es la longitud del nombre real del fichero en bytes, 8, 10 y 6 en este ejemplo. Finalmente, viene el propio nombre del fichero, terminado por un byte 0 y rellenado hasta un límite de 32 bits. Después puede haber más relleno.

[figure10-32]

En la Fig. 10-32(b) vemos el mismo directorio después de eliminar la entrada de voluminoso. Todo lo que la eliminación ha hecho es incrementar el tamaño del campo de entrada total para colossal, convirtiendo el campo anterior para voluminous en relleno para la primera entrada. Por supuesto, este relleno puede utilizarse para una entrada posterior.

Dado que los directorios se buscan linealmente, puede llevar mucho tiempo encontrar una entrada al final de un directorio grande. Por ello, el sistema mantiene una caché de los directorios a los que se ha accedido recientemente. Esta caché se busca utilizando el nombre del archivo, y si se produce un acierto, se evita la costosa búsqueda lineal.  Se introduce un objeto *dentry* en la caché *dentry* para cada uno de los componentes de la ruta y, a través de su nodo i, se busca en el directorio la entrada del elemento de ruta subsiguiente, hasta que se alcanza el nodo i del archivo real.

Por ejemplo, para buscar un archivo especificado con un nombre de ruta absoluto, como /usr/ast/file, se requieren los siguientes pasos. En primer lugar, el sistema localiza el directorio raíz, que generalmente utiliza el nodo-i 2, especialmente cuando el nodo-i 1 está reservado para la gestión de bloques abandonados. Coloca una entrada en la memoria caché para futuras búsquedas del directorio raíz. A continuación, busca la cadena ''usr'' en el directorio raíz para obtener el número de nodo-i del directorio /usr, que también se introduce en la caché dentry. Este nodo-i es entonces recuperado, y los bloques de disco son extraídos de él, para que el directorio /usr pueda ser leído y buscado por la cadena "ast". Una vez encontrada esta entrada, se puede obtener el número de nodo-i para el directorio /usr/ast. Con el número de nodo-i del directorio /usr/ast, se puede leer este nodo-i y localizar los bloques del directorio. Por último, se busca "file" y se encuentra su número de nodo-i. Por lo tanto, el uso de un nombre de ruta relativo no sólo es más cómodo para el usuario, sino que también ahorra una cantidad substancial de trabajo al sistema.

Si el archivo está presente, el sistema extrae el número de nodo-i y lo utiliza como índice en la tabla de nodos-i (en disco) para localizar el nodo-i correspondiente y traerlo a la memoria. El nodo-i se introduce en la **i-node table**, una estructura de datos del kernel que contiene todos los nodos-i de los archivos y directorios abiertos en ese momento. El formato de las entradas del nodo-i, como mínimo, debe contener todos los campos devueltos por la llamada al sistema stat para que stat funcione (ver Fig. 10-28).  En la Fig. 10-33 mostramos algunos de los campos incluidos en la estructura del nodo-i soportada por la capa del sistema de ficheros de Linux. La estructura real del nodo-i contiene muchos más campos, ya que la misma estructura también se utiliza para representar directorios, dispositivos y otros ficheros especiales. La estructura del nodo-i también contiene campos reservados para uso futuro. La historia ha demostrado que los bits no utilizados no permanecen así mucho tiempo.

[figure 10-33]

Veamos ahora cómo lee el sistema un fichero. Recordemos que una llamada típica al procedimiento de la biblioteca para invocar la llamada a la system call read el siguiente aspecto:

``` C
    n=read(fd,buffer,nbytes);
```

Cuando el kernel toma el control, todo lo que tiene para empezar son estos tres parámetros y la información de sus tablas internas relacionadas con el usuario. Uno de los elementos de las tablas internas es la matriz de descriptores de archivo. Está indexada por un descriptor de archivo y contiene una entrada por cada archivo abierto (hasta el número máximo, normalmente 32 por defecto). 

La idea es empezar con este descriptor de fichero y terminar con el nodo-i correspondiente. Consideremos un diseño posible: basta con poner un puntero al nodoi en la tabla de descriptores de fichero. Aunque sencillo, por desgracia este método no funciona.

El problema es el siguiente. Asociado a cada descriptor de fichero hay una posición de fichero que indica en qué byte empezará la siguiente lectura (o escritura). ¿Dónde debe ir? Una posibilidad es ponerla en la tabla i-node. Sin embargo, este enfoque falla si dos o más procesos no relacionados abren el mismo archivo al mismo tiempo porque cada uno tiene su propia posición de archivo. 

Una segunda posibilidad es poner la posición del fichero en la tabla de descriptores de ficheros. De esta forma, cada proceso que abre un fichero obtiene su propia posición privada. Desafortunadamente, este esquema también falla, pero el razonamiento es más sutil y tiene que ver con la naturaleza de compartir archivos en Linux. Considere un script de shell, s, que consiste en dos comandos, p1 y p2, que deben ejecutarse en orden. Si el script es invocado por el comando

``` shell
    s>x
```

 se espera que p1 escriba su salida en x, y luego p2 escriba su salida en x también, comenzando en el lugar donde p1 se detuvo.

 Cuando el shell forkea p1, x está inicialmente vacío, por lo que p1 simplemente comienza a escribir en la posición 0. Sin embargo, cuando p1 termina, se necesita algún mecanismo para asegurarse de que la posición inicial de archivo que p2 ve no es 0 (que sería si la posición de archivo se mantuviera en la tabla de descriptores
 de archivo), sino el valor con el que p1 terminó.

En la Fig. 10-34 se muestra la forma de conseguirlo.  El truco es introducir una nueva tabla, la tabla **open-file-description**, entre la tabla file descriptor y la tabla i-node, y poner la posición del archivo (y el bit de lectura/escritura) allí. En esta figura, el padre es el shell y el hijo es primero p1 y después p2. Cuando el shell se bifurca dep1, su estructura de usuario (incluida la tabla de descriptores de archivos) es una copia exacta de la del shell, por lo que ambos apuntan a la misma entrada de la tabla de descripción de archivos abiertos. Cuandop1 termina, el descriptor de fichero de la shell sigue apuntando a la descripción de fichero abierto que contiene la posición de fichero de p1. Cuando el shell forkea p2, el nuevo hijo hereda automáticamente la posición del archivo, sin que ni él ni el shell tengan que saber cuál es esa posición.

Sin embargo, si un proceso no relacionado abre el archivo, obtiene su propia entrada open-file-de-scription, con su propia posición de archivo, que es precisamente lo que se necesita. Así, el objetivo de la tabla open-file-description es permitir que un padre y un hijo compartan una posición de archivo, pero proporcionar a los procesos no relacionados sus propios valores.

Volviendo al problema de read, ya hemos visto cómo se ubican la posición del fichero y el nodo i. El nodo i contiene las direcciones de disco de los 12 primeros bloques del fichero. El nodo i contiene las direcciones de disco de los 12 primeros bloques del archivo.  Si la posición del archivo cae en los primeros 12 bloques, se lee el bloque y se copian los datos al usuario. Para archivos de más de 12 bloques, un campo del nodo i contiene la dirección de disco de un **single indirect block**, como se muestra en la Fig. 10-34. Este bloque contiene las direcciones de disco de más de un bloque indirecto. Este bloque contiene las direcciones de disco de más bloques de disco. Por ejemplo, si un bloque es de 1 KB y una dirección de disco es de 4 bytes, el bloque indirecto único puede contener 256 direcciones de disco. Por lo tanto, este esquema funciona para archivos de hasta 268 KB.

A partir de ahí, se utiliza un **double indirect block**. Contiene las direcciones de 256 bloques indirectos simples, cada uno de los cuales contiene las direcciones de 256 bloques de datos. Este mecanismo es suficiente para gestionar archivos de hasta 10 + 216 bloques (67.119.104 bytes). Si esto no es suficiente, el nodo i tiene espacio para un **triple indirect block**. Sus punteros apuntan a muchos bloques indirectos dobles. Este esquema de direccionamiento puede manejar tamaños de archivo de bloques de 2241 KB (16 GB). Para tamaños de bloque de 8 KB, el esquema de direccionamiento puede soportar tamaños de archivo de hasta 64 TB.

### The Linux Ext4 File System

Para evitar la pérdida de datos en caso de caída del sistema o fallo de alimentación, el sistema de archivosext2 tendría que escribir cada bloque de datos en el disco tan pronto como se creara. La latencia en la que se incurriría durante la operación de búsqueda en la cabeza del disco sería tan alta que el rendimiento sería intolerable. Por lo tanto, las escrituras se retrasan, y los cambios pueden no confirmarse en el disco hasta 30 segundos, que es un intervalo de tiempo muy largo en el contexto del hardware informático moderno.

Para mejorar la robustez del sistema de archivos, Linux recurre a los **journaling file systems**. **Ext3**, sucesor del sistema de archivos ext2, es un ejemplo de sistema de archivos con registro en diario. **Ext4**, sucesor de ext3, también es un sistema de archivos de registro por diario, pero a diferencia de ext3, cambia el esquema de direccionamiento de bloques utilizado por sus predecesores, permitiendo así archivos más grandes y sistemas de archivos de mayor tamaño. A continuación describiremos algunas de sus características.

La idea básica de un sistema de archivos con registro en el diario es mantener un *journal* que describa todas las operaciones del sistema de archivos en orden secuencial. Al escribir secuencialmente los cambios en los datos o metadatos del sistema de archivos (nodos-i, superbloque, etc.), las operaciones no sufren las sobrecargas del movimiento del cabezal del disco durante los accesos aleatorios al disco. Finalmente, los cambios se escribirán, se confirmarán, en la ubicación de disco apropiada, y las entradas del diario correspondientes pueden descartarse. Si se produce una caída del sistema o un fallo de alimentación antes de que se confirmen los cambios, durante el reinicio el sistema detectará que el sistema de archivos no se desmontó correctamente, recorrerá el diario y aplicará los cambios en el sistema de archivos descritos en el registro del diario.

Ext4 está diseñado para ser altamente compatible con ext2 y ext3, aunque sus estructuras de datos core y la disposición del disco están modificadas. En cualquier caso, un sistema de archivos que se haya desmontado como sistema ext2 puede montarse posteriormente como sistema ext4 y ofrecer la capacidad de registro en diario.

El journal es un archivo gestionado como un buffer circular. El diario puede almacenarse en el mismo dispositivo que el sistema de archivos principal o en uno distinto. Dado que las operaciones del diario no están "registradas" en sí mismas, no son gestionadas por el mismo sistema de archivos ext4. En su lugar, se utiliza un **JBD (Journaling Block Device)** separado para realizar las operaciones de lectura/escritura del diario.

JBD admite tres estructuras de datos principales: *log recorded*, *atomic operation handle* y *transaction*. Un log record describe una operación de bajo nivel del sistema de archivos, que normalmente produce cambios dentro de un bloque. Dado que una llamada al sistema comowr ite incluye cambios en múltiples lugares (nodos-i, bloques de archivos existentes, nuevos bloques de archivos, lista de tres bloques, etc.), los registros de registro relacionados se agrupan en operaciones atómicas. Ext4 notifica a JBD el inicio y el final del procesamiento de la llamada al sistema, de modo que JBD pueda garantizar que se apliquen todos los registros de una operación atómica o ninguno de ellos. Por último, principalmente por razones de eficiencia, JBD trata las colecciones de operaciones atómicas como transacciones.  Los registros se almacenan consecutivamente dentro de una transacción. JBD permitirá que se descarten partes del archivo de diario sólo después de que todos los registros de una transacción se hayan consignado de forma segura en el disco.

Dado que escribir una entrada de registro para cada cambio de disco puede ser costoso, ext4 puede configurarse para mantener un diario de todos los cambios de disco, o sólo de los cambios relacionados con los metadatos del sistema de archivos (los i-nodos, superbloques, etc.). El registro en el diario sólo de los metadatos reduce la sobrecarga del sistema y mejora el rendimiento, pero no ofrece ninguna garantía contra la corrupción de los datos del archivo. Otros sistemas de archivos con registro en diario sólo mantienen registros de las operaciones de metadatos (por ejemplo, XFS de SGI).  Además, la fiabilidad del diario puede mejorarse aún más mediante la suma de comprobación. 

La principal modificación de ext4 con respecto a sus predecesores es el uso de extents, que representan bloques contiguos de almacenamiento, por ejemplo, 128 MB de bloques contiguos de 4 KB, frente a los bloques de almacenamiento individuales a los que hacía referencia ext2. A diferencia de sus predecesores, ext4 no requiere operaciones de metadatos para cada bloque de almacenamiento. Este esquema también reduce la fragmentación de los archivos de gran tamaño. Como resultado, ext4 puede proporcionar operaciones de sistema de archivos más rápidas y soportar archivos y tamaños de sistema de archivos más grandes. Por ejemplo, para un tamaño de bloque de 1 KB, ext4 aumenta el tamaño máximo de archivo de 16 GB a 16 TB, y el tamaño máximo del sistema de archivos a 1 EB (Exabyte).
